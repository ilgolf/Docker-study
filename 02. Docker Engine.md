# 02. Docker Engine

## 도커 이미지와 컨테이너

도커 엔진에서 사용하는 기본 단위는 이미지와 컨테이너이며, 이 두가지가 도커 엔진의 핵심입니다.

## 도커 이미지

이미지는 컨테이너를 생성할 때 필요한 요소이며, 가상 머신을 생성할 때 사용하는 iso파일과 비슷한 개념입니다. 이미지는 바이너리 파일로 존재하며, 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용됩니다.

구조는 다음과 같습니다.

```
저장소이름/이미지이름:<태그>

ex) golf/jenkins:1.12.4            jenkins:latest
```

- 저장소 : 이미지가 저장된 저장소를 의미, 저장소가 명시되어있지 않으면 보통 Docker hub에 저장된 공식 이미지입니다.
- 이미지 이름 : 이미지가 어떤 역할을 하는지 식별하기 위해 만드는 경우가 많습니다. 예를들어 jenkins가 이름이면 해당 이미지는 보통 jenkins의 역할을 수행하게 됩니다.
- 태그 : 이미지 버전 관리 혹은 리비전 관리에 사용됩니다. 태그를 생략하면 이미지의 태그를 latest로 인식합니다.

## 도커 컨테이너

도커 이미지는 Jenkins 뿐만 아니라 MySQL, Redis, Kafka 등 여러가지 종류가 있습니다. 이러한 이미지로 컨테이너를 생성하면 해당 이미지의 목적에 맞는 파일이 들어있는 파일 시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성됩니다. 

컨테이너는 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 컨테이너 계층에 저장하므로 컨테이너에서 무엇을 하던지 이미지는 영향을 받지 않습니다. 또한 생성된 각 컨테이너는 각기 독립된 파일 시스템을 제공 받으며 호스트와 분리돼 있으므로 특정 컨테이너에서 어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 호스트는 변화가 없습니다.

## 컨테이너 생성

`docker run -i -t ubunu:14.04` 명령어로 간단하게 컨테이너를 생성할 수 있습니다. 이 때 docker run 명령어에 -i -t 옵션 (상호 입 출력을 가능하게 합니다.) 마지막으로 이미지 명과 태그를 명시하면 ubuntu 컨테이너가 실행됩니다. 

옵션은 다음과 같이 존재합니다.

- -i : 상호 입출력
- -t : tty를 활용해서 배시 셸 사용
- --name : 컨테이너 이름 지정(유용)
- -p : 포트 바인딩
- -d : detach 모드로 백그라운드 실행(입출력 없는 상태로 실행, 포그라운드로 실행)
- -e : 컨테이너 내부 환경 변수 설정(docs 참조)
- --link : IP가 아닌 컨테이너 별명으로 컨테이너끼리 접근하는 기술,(타겟_컨테이너/타겟_별칭)
    - 현재는 deprecated -> 도커 브릿지를 이용

이렇게 만들어진 컨테이너는 `docker exec -it <컨테이너 명> bash` 명령어로 서버내에 접근할 수 있으며 ls 명령어 등을 이용하여 서버 내부를 확인하실 수 있습니다.

## 컨테이너를 외부에 노출

컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당 받습니다. 기본적으로 도커는 컨테이너에 172.17.0.x IP를 순차적으로 할당합니다. 컨테이너를 생성한 후 접속하여 ifconfig로 네트워크 인터페이스를 확인할 수 있습니다.

하지만 컨테이너에 아무런 설정을 하지 않으면 이 컨테이너는 외부에서 접근할 수가 없고 설치된 호스트에서만 접근할 수 있는데 만약 외부에 컨테이너의 애플리케이션을 노출하려면 eth0의 IP와 호스트 IP 포트를 바인딩 해야합니다. 

`docker run -i -t --name my-jenkins -p 8000:8080 jenkins:latest`

-p 옵션은 컨테이너의 포트를 호스트의 포트와 바인딩하여 연결할 수 있게 설정합니다. 이때 내부에 여러 개의 포트가 있다면 -p를 여러번 사용하여 포트 바인딩을 해줍시다.

원리는 다음과 같습니다. 

![Untitled](https://user-images.githubusercontent.com/77387861/213843783-4e47dc98-a064-41a7-822f-83c898692d5e.png)


호스트 IP 8000번으로 접근 → 8000번 포트는 컨테이너의 8080 포트로 포워딩 → 서비스 접근

## 도커 볼륨

도커로 띄운 mysql 이미지가 있다고 가정해봅니다. 이 때 구조는 다음과 같이 나타나집니다. 

![Untitled (2)](https://user-images.githubusercontent.com/77387861/214331287-ad6824bb-7038-41e0-b275-efa9e73176d9.png)


이미 생성된 이미지는 변경되지 않으며, 컨테이너 계층에 원래 이미지에서 변경된 파일 시스템 등을 저장합니다. 워드프레스에서 쓴 로그인 정보나 게시글 등과 같아 데이터베이스를 운용하면서 쌓이는 데이터가 저장됩니다.

하지만 이 구조는 치명적인 단점이 있습니다. mysql 컨테이너가 삭제되면 컨테이너 계층에 있는 데이터베이스의 정보도 같이 삭제가 된다는 것입니다. 또한 복구도 할 수 없습니다. 

도커는 이러한 단점을 극복하기 위해 영속적으로 보관할 수 있는 방법을 몇가지 제시하는데 그 중 가장 쉽게 활용할 수 있는 방법이 도커 볼륨을 이용하는 것입니다.

볼륨을 활용하는 방법은 여러가지가 있습니다. 호스트와 볼륨을 공유할 수도 있고, 볼륨 컨테이너를 활용할 수도 있으며, 도커가 관리하는 볼륨을 생성할 수도 있습니다. 

그럼 첫 번째 방법 부터 확인해 봅시다.

```bash
docker run -d \
-- name my-mysql \
-e MYSQL_ROOT_PASSWORD=password \
-e MYSQL_DATABASE=member \
-v /home/my-mysql_db:/var/lib/mysql \
mysql:5.7
```

```bash
docker run -d \
-e MY_MYSQL_DB_PASSWORD=password \
-- name my-mysql_hostvolume \
-- link my-mysql_hostvolume:mysql \
-p 80 \
my-mysql
```

my-mysql 컨테이너에 -p 옵션으로 컨테이너의 80포트를 외부에 노출했으므로 docker ps 명령어에서 확인한 `my-mysql_hostvolume` 컨테이너의 호스트 포트로 my-mysql 컨테이너에 접속할 수 있습니다. 

-v 옵션을 이용하여 실행 시 볼륨을 추가해줬고 그 값은 `/home/my-mysql_db:/var/lib/mysql`로 설정한 것입니다. 이는 호스트의 `/home/my-mysql_db`와 컨테이너의 `/var/lib/mysql`를 공유한다는 듯입니다. 

즉, [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리] 형태로 보시면 좋습니다.

이렇게 되면 컨테이너가 삭제되더라도 볼륨에 계속 남아있기 때문에 로컬만 데이터가 남아있다면 언제든 데이터를 재사용할 수 있습니다.
